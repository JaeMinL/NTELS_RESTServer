#include <unistd.h>
#include <stdio.h>
#include <mysql/mysql.h>
#include <stdlib.h>
#include <string.h>
#include <json/json.h>
//#include <json-c/json.h>

#include "gendef.h"
#include "comlib.h"
#include "comlib.x"
#include "thrlib.h"
#include "thrlib.x"
#include "trnlib.h"
#include "trnlib.x"
#include "loglib.h"
#include "loglib.x"
#include "rrllib.h"
#include "rrllib.x"
#include "rsvlib.h"
#include "rsvlib.x"

#include "rest_stat.h"

#define DB_HOST "192.168.6.84"
#define DB_USER "sdv"
#define DB_PW "sdv2016"
#define DB_NAME "SDV"
#define QUERY_LEN 1024
#define TABLE_LEN 64
#define CMP_LEN 1
#define DASH_IDX 10

FT_PUBLIC RT_RESULT Host_1min(UINT mthod, RsvlibSesCb *sesCb);
FT_PUBLIC RT_RESULT Host_5min(UINT mthod, RsvlibSesCb *sesCb);
FT_PUBLIC RT_RESULT Host_hour(UINT mthod, RsvlibSesCb *sesCb);
FT_PUBLIC RT_RESULT Host_day(UINT mthod, RsvlibSesCb *sesCb);

FT_PUBLIC RT_RESULT Svc_1min(UINT mthod, RsvlibSesCb *sesCb);
FT_PUBLIC RT_RESULT Svc_5min(UINT mthod, RsvlibSesCb *sesCb);
FT_PUBLIC RT_RESULT Svc_hour(UINT mthod, RsvlibSesCb *sesCb);
FT_PUBLIC RT_RESULT Svc_day(UINT mthod, RsvlibSesCb *sesCb);

FT_PUBLIC RT_RESULT Host_1min_time(UINT mthod, RsvlibSesCb *sesCb);

FT_PUBLIC RT_RESULT DbResult(CHAR * query, RsvlibSesCb *sesCb, CHAR *who);

FT_PUBLIC RT_RESULT MakeQueryByInfo(RsvlibSesCb *sesCb, CHAR *who, CHAR *term);
///
FT_PUBLIC RT_RESULT MakeQueryByIP(RsvlibSesCb *sesCb, CHAR *who, CHAR *term);
FT_PUBLIC RT_RESULT MakeQueryByTime(RsvlibSesCb *sesCb, CHAR *who, CHAR *term);


FT_PUBLIC CHAR * ChDate(CHAR *s) {
	s[DASH_IDX]=' ';
	return s;
}


FT_PUBLIC RT_RESULT DbResult(CHAR * query, RsvlibSesCb *sesCb, CHAR *who){
	MYSQL *conn = NULL;
	MYSQL_RES *res = NULL;
	MYSQL_ROW row = NULL;
	MYSQL_FIELD *fields = NULL;
	UINT field_cnt = 0;
	UINT i, j;
	UINT row_cnt = 0;

	SINT ret = RC_NOK;
	
	json_object *who_obj;
	json_object *data_obj;
	json_object *array_obj;

	conn = mysql_init(NULL);
	if( conn == NULL){
		fprintf(stderr, "%s\n", mysql_error(conn));
		exit(1);
	}
	
	if(mysql_real_connect(conn, DB_HOST, DB_USER, DB_PW, DB_NAME, 0, NULL, 0) == NULL)
	{
		fprintf(stderr, "%s\n", mysql_error(conn));
		mysql_close(conn);
		exit(1);
	}
	printf("\n\n%s\n", query);
	if(NULL != mysql_query(conn, query)){
		fprintf(stderr, "%s\n", mysql_error(conn));
		mysql_close(conn);
		exit(1);
	}
	res = mysql_store_result(conn);
	if(res == NULL){
		fprintf(stderr, "%s\n", mysql_error(conn));
		mysql_close(conn);
		exit(1);
	}

	row_cnt = mysql_num_rows(res);
	field_cnt = mysql_num_fields(res);
	fields = mysql_fetch_fields(res);

	who_obj = json_object_new_object();
	if(who_obj == NULL){
		fprintf(stderr, "DbResult -> who_obj create fail!\n");
		mysql_close(conn);
		exit(1);
	}
	
	array_obj = json_object_new_array();	
	printf("row 갯수 : %d\n",row_cnt);	
	while((row = mysql_fetch_row(res)) != NULL)
	{
		if(who_obj == NULL){
			fprintf(stderr, "DbResult -> array_obj create fail!\n");
			mysql_close(conn);
			mysql_free_result(res);
			exit(1);
		}

		data_obj = json_object_new_object();
		for(i=0; i<field_cnt; i++)
		{
			if(who_obj == NULL){
				fprintf(stderr, "DbResult -> who_obj create fail!\n");
				mysql_close(conn);
				mysql_free_result(res);
				exit(1);
			}
			
			json_object_object_add(data_obj, fields[i].name, json_object_new_string(row[i]));
		}
		json_object_array_add(array_obj, data_obj);
	}
	json_object_object_add(who_obj, who, array_obj);

	//ret = rsvlib_apiSetRspDat(sesCb, (CHAR *)json_object_to_json_string(who_obj), RC_TRUE);
	ret = rsvlib_apiSetRspDat(sesCb, (CHAR *)json_object_get_string(who_obj), RC_TRUE);
	if(ret != RC_OK){
		fprintf(stderr, "DbResult -> rsvlib_apiSetRspDat() call fail!\n");
		mysql_close(conn);
		exit(1);
	}

	//free
	for(i=0; i<row_cnt; i++)
	{	
		for(j=0; j<field_cnt; j++)
		{
			//json_object_object_del(json_object_array_get_idx(array_obj, 0), fields[j].name);
			json_object_put(json_object_object_get(json_object_array_get_idx(array_obj, 0), fields[j].name));
		}
		json_object_put(json_object_array_get_idx(array_obj, 0));
	}

	json_object_put(array_obj);
	json_object_put(who_obj);
	//rsvlib_apiSetRspDat(sesCb, query, RC_TRUE);
	mysql_free_result(res);
	mysql_close(conn);

	return RC_OK;
}

FT_PUBLIC RT_RESULT MakeQueryByInfo(RsvlibSesCb *sesCb, CHAR *who, CHAR *term){
    RrllibDocArg *docArg = NULL;
    UINT strDataLen = 0;
    CONST CHAR *strData = NULL;
    CHAR query[QUERY_LEN];
    CHAR table[TABLE_LEN];
    CHAR *which = NULL;
    CHAR *argName = "name";
    CHAR *argIP = "ip";
    CHAR *who_s = NULL;


    memset(query, 0, QUERY_LEN);
    memset(table, 0, TABLE_LEN);

    SINT ret = RC_NOK;
    ret = rsvlib_apiFindArg(sesCb, argName, &docArg);
    if(ret != RC_OK){
	ret = rsvlib_apiFindArg(sesCb, argIP, &docArg);
    	if(ret != RC_OK){
        	fprintf(stderr, "no arg : %s & %s\n", argIP, argName);
        	exit(1);
    	}
	which = "IP";
    }
    else{which = "NAME";}

    ret = rsvlib_apiFirstArgVal(docArg, &strData, &strDataLen);
    if(ret != RC_OK){
    	fprintf(stderr, "strName=%s\n", strData);
    	return RC_NOK;
    }    

    if(!comlib_strCmp("SERVICE", who)){who_s = "SVC";}
    else{who_s = who;}

    if(term == NULL){
    	snprintf(table, TABLE_LEN, "TSD_STAT_%s", who);
    }
    else{
    	snprintf(table, TABLE_LEN, "TSD_STAT_%s_%s", who, term);
    }
   snprintf(query, QUERY_LEN, "SELECT b.%s_NAME, a.* FROM %s a, TSD_%s b WHERE a.%s_ID = b.%s_ID AND b.%s_%s = '%s'", who, table, who_s, who, who, who, which, strData); 
    
    ret = DbResult(query, sesCb, who);
    if(ret != RC_OK)
    {
    	fprintf(stderr, "DbResult() error");
    	exit(1);
    }

    return RC_OK;
}

FT_PUBLIC RT_RESULT MakeQueryByTime(RsvlibSesCb *sesCb, CHAR *who, CHAR *term){printf("makeQueryByTime\n");
    RrllibDocArg *docArg = NULL;
    UINT strSttLen = 0;
    UINT strEndLen = 0;
    CHAR *strStt = NULL;
    CHAR *strEnd = NULL;
    CHAR query[QUERY_LEN];
    CHAR table[TABLE_LEN];
    CHAR where[QUERY_LEN];
    CHAR *arg_stt = "start";
    CHAR *arg_end = "end";
    CHAR *who_s = who;

    memset(query, 0, QUERY_LEN);
    memset(table, 0, TABLE_LEN);

    SINT ret = RC_NOK;

    if(comlib_strNCmp("SERVICE", who, comlib_strGetLen(who)) == RC_OK){who_s = "SVC";}

    if(term == NULL){
	snprintf(table, TABLE_LEN, "TSD_STAT_%s", who);
    }
    else{
	snprintf(table, TABLE_LEN, "TSD_STAT_%s_%s", who, term);
    }

    ret = rsvlib_apiFindArg(sesCb, arg_stt, &docArg);
    if(ret != RC_OK){
	    ret = rsvlib_apiFindArg(sesCb, arg_end, &docArg);
	    if(ret != RC_OK){
	    	snprintf(where, QUERY_LEN, " ");
	    	// //전체.....? end& start 없음
			// snprintf(where, QUERY_LEN, "WHERE ");
		}
	    ret = rsvlib_apiFirstArgVal(docArg, &strEnd, &strEndLen);
	    if(ret != RC_OK){
		fprintf(stderr, "strEnd=%s\n", strEnd);
		return RC_NOK;
	    }
	    else{
		strEnd = ChDate(strEnd);
		
		//~end까지
		snprintf(where, QUERY_LEN, "PRC_DATE <= '%s' ", strEnd);
	    }

    }
    else{
   	ret = rsvlib_apiFirstArgVal(docArg, &strStt, &strSttLen);
   	if(ret != RC_OK){
   		fprintf(stderr, "strStt=%s\n", strStt);
		exit(1);
   	}

	ret = rsvlib_apiFindArg(sesCb, arg_end, &docArg);
	if(ret != RC_OK){
		strStt = ChDate(strStt);

	    	// start~부터
	    	snprintf(where, QUERY_LEN, "PRC_DATE >= '%s' ", strStt);
	}
	else{
		ret = rsvlib_apiFirstArgVal(docArg, &strEnd, &strEndLen);
		if(ret != RC_OK){
			fprintf(stderr, "strEnd=%s\n", strEnd);
			exit(1);
		}
		else{
			strStt = ChDate(strStt);
			strEnd = ChDate(strEnd);
			
			//start ~end까지
			snprintf(where, QUERY_LEN, "PRC_DATE >= '%s' AND PRC_DATE <= '%s' ", strStt, strEnd);
		}
	}
		
    }	
	if(!comlib_strCmp("SERVICE", who)){who_s = "SVC";}
    	else{who_s = who;}

    	snprintf(query, QUERY_LEN, "SELECT b.%s_NAME, a.* FROM %s a, TSD_%s b WHERE a.%s_ID = b.%s_ID AND %s", who, table, who_s, who, who, where);
	
    	ret = DbResult(query, sesCb, who);
	if(ret != RC_OK)
	{
		fprintf(stderr, "DbResult() error");
		exit(1);
	}

	return RC_OK;
}




FT_PUBLIC RT_RESULT Host_1min(UINT mthod, RsvlibSesCb *sesCb){
	SINT ret = RC_NOK;

	ret = MakeQueryByInfo(sesCb, "HOST", NULL);
	if(ret != RC_OK){
		fprintf(stderr, "Host_1min() error");
		exit(1);
	}

	return RC_OK;
}
FT_PUBLIC RT_RESULT Host_5min(UINT mthod, RsvlibSesCb *sesCb){
	SINT ret = RC_NOK;

	ret = MakeQueryByInfo(sesCb, "HOST", "5MIN");
	if(ret != RC_OK){
		fprintf(stderr, "Host_5min() error");
		exit(1);
	}

	return RC_OK;
}

FT_PUBLIC RT_RESULT Host_hour(UINT mthod, RsvlibSesCb *sesCb){
	SINT ret = RC_NOK;

	ret = MakeQueryByInfo(sesCb, "HOST", "HOUR");
	if(ret != RC_OK){
		fprintf(stderr, "Host_hour() error");
		exit(1);
	}

	return RC_OK;
}

FT_PUBLIC RT_RESULT Host_day(UINT mthod, RsvlibSesCb *sesCb){printf("host_day func\n");
	SINT ret = RC_NOK;

	ret = MakeQueryByInfo(sesCb, "HOST", "DAY");
	if(ret != RC_OK){
		fprintf(stderr, "Host_day() error");
		exit(1);
	}

	return RC_OK;
}

FT_PUBLIC RT_RESULT Svc_1min(UINT mthod, RsvlibSesCb *sesCb){
	SINT ret = RC_NOK;

	ret = MakeQueryByInfo(sesCb, "SERVICE", NULL);
	if(ret != RC_OK){
		fprintf(stderr, "SDV_1min() error");
		exit(1);
	}

	return RC_OK;
}
FT_PUBLIC RT_RESULT Svc_5min(UINT mthod, RsvlibSesCb *sesCb){
	SINT ret = RC_NOK;

	ret = MakeQueryByInfo(sesCb, "SERVICE", "5MIN");
	if(ret != RC_OK){
		fprintf(stderr, "SDV_5min() error");
		exit(1);
	}

	return RC_OK;
}
FT_PUBLIC RT_RESULT Svc_hour(UINT mthod, RsvlibSesCb *sesCb){printf("svc_hour");
	SINT ret = RC_NOK;

	ret = MakeQueryByInfo(sesCb, "SERVICE", "HOUR");
	 if(ret != RC_OK){
		fprintf(stderr, "SDV_hour() error");
		exit(1);
	}

	return RC_OK;
}
FT_PUBLIC RT_RESULT Svc_day(UINT mthod, RsvlibSesCb *sesCb){
	SINT ret = RC_NOK;

	ret = MakeQueryByInfo(sesCb, "SERVICE", "DAY");
	if(ret != RC_OK){
		fprintf(stderr, "SDV_day() error");
		exit(1);
	}

	return RC_OK;
}

FT_PUBLIC RT_RESULT Host_1min_time(UINT mthod, RsvlibSesCb *sesCb){
	SINT ret = RC_NOK;

        ret = MakeQueryByTime(sesCb, "HOST", NULL);
        if(ret != RC_OK){
                fprintf(stderr, "HOST_1min_time() error");
                exit(1);
        }

        return RC_OK;
}

FT_PUBLIC VOID logPrnt(UINT lvl, CHAR *file, UINT line, CHAR *logStr)
{
    printf("[%d][%s:%d] %s\n",lvl, file, line, logStr);
}

int main()
{
    SINT ret = RC_OK;
    LoglibCfg logCfg;
    RsvlibGenCfg rsvCfg;
    LoglibCb loglibCb;
    
    /* log setting */
    LOGLIB_GLOB_INIT();

    LOGLIB_INIT_CFG(&logCfg);

    loglib_apiInitLoglibCb(&loglibCb, &logCfg);

    /* rest server setting */
    RSV_INIT_GEN_CFG(&rsvCfg, 8800);

    ret = rsvlib_apiInit(1, &rsvCfg);
    if(ret != RC_OK){
        LOGLIB_ERR(&loglibCb, "REST SERVER INIT FAILED(ret=%d)\n", ret);
        return -1;
    }

    rsvlib_apiSetLogFunc(RSV_DBG, logPrnt);
    /* url rule setting */
/*  CHAR *term[] = {"1min", "5min", "hour", "day"};
    CHAR *who[] = {"Host", "Sdv"};
    CHAR url[QUERY_LEN];
    CHAR func[QUERY_LEN];
    memset(url, 0, sizeof(CHAR) * QUERY_LEN);
    memset(func, 0, sizeof(CHAR) * QUERY_LEN);
	
    for(i = 0; i < (UINT)sizeof(term)/sizeof(term[0]) ; i++){
	printf("%zu", sizeof(term)/sizeof(term[0]));
    	for(j = 0; j < (UINT)sizeof(who)/sizeof(who[0]) ; j++){
		//snprintf(url, QUERY_LEN, "'/%s/%s'", comlib_strToLower(who[j]), term[i]);
		snprintf(func, QUERY_LEN, "%s_%s", who[j], term[i]);

		//ret = rsvlib_apiSetRule(1, RSV_MTHOD_GET, url, "{name}", NULL, func);
		printf("url : %s, func : %s", url, func);
		if(ret != RC_OK){
			fprintf(stderr, "setRule error");
			exit(1);
		}

		memset(url, 0, sizeof(CHAR) * QUERY_LEN);
		memset(func, 0, sizeof(CHAR) * QUERY_LEN);
		snprintf(url, QUERY_LEN, "'/%s/%s/time'", comlib_strToLower(who[j]), term[i]);
		snprintf(func, QUERY_LEN, "%s_%s_time", who[j], term[i]);
		ret = rsvlib_apiSetRule(1, RSV_MTHOD_GET, url, "[start] [end]", NULL, func);
		if(ret != RC_OK){
			fprintf(stderr, "setRule error");
			exit(1);
		}

		memset(url, 0, sizeof(CHAR) * QUERY_LEN);
		memset(func, 0, sizeof(CHAR) * QUERY_LEN);
    	}
    }
*/
    ret = rsvlib_apiSetRule(1, RSV_MTHOD_GET, "/host/1min", "[name][ip]", NULL, Host_1min);
    ret = rsvlib_apiSetRule(1, RSV_MTHOD_GET, "/host/5min", "[name][ip]", NULL, Host_5min);
    ret = rsvlib_apiSetRule(1, RSV_MTHOD_GET, "/host/hour", "[name][ip]", NULL, Host_hour);
    ret = rsvlib_apiSetRule(1, RSV_MTHOD_GET, "/host/day", "[name][ip]", NULL, Host_day);

    ret = rsvlib_apiSetRule(1, RSV_MTHOD_GET, "/svc/1min", "{name}", NULL, Svc_1min);
    ret = rsvlib_apiSetRule(1, RSV_MTHOD_GET, "/svc/5min", "{name}", NULL, Svc_5min);
    ret = rsvlib_apiSetRule(1, RSV_MTHOD_GET, "/svc/hour", "{name}", NULL, Svc_hour);    
    ret = rsvlib_apiSetRule(1, RSV_MTHOD_GET, "/svc/day", "{name}", NULL, Svc_day);    

    ret = rsvlib_apiSetRule(1, RSV_MTHOD_GET, "/host/1min/time", "[start][end]", NULL, Host_1min_time);
    
	/* run rest server */
    rsvlib_apiRun(1);

    while(1){
        sleep(1);
    }

    return 0;
}
